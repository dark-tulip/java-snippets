## GO - он идеально продуман для работы с сетью. Google прекрасно аккумулировали свой опыт 


- Lock Guard берет лок на метод во время конструктора и освобождает полсе деструктора
- Лок гуарды нужны для освобождения ресурса после вызова деструктора на этот объект.
- Это лучше чем каждый раз в коде вызывать мьютекс лок и анлок

> Всегда используйте тот класс, которого достаточно. Нет смысла гадать, зачем использовали ракету.

----

# Проблемы асинхронной обработки

- Без шаблонов `Atomic Load and Atomic Store` невозможно написать `Mutex`
- Используйте Атомики там, где потоки работают с переменной без должной синхронизации
  
## 1. Race Condition (состояние гонки)

- когда два потока одновременно берут операцию на ресурс. По коду кажется что все атомарна, но изза этой причины происходят двойные вставка или обновления
- результат вычислений зависит от порядка действий
- **Решение. Сначала записывать потом публиковать. Соблюдать принцип happens before**
## 2. Data race (гонка на данных)

- когда два потока одновременно ссылаются на одну ячейку памяти. Один из них вносит изменения, другой не видит и читает старый вариант
- это частный случай Race Condition
- **Решение. По возможности использовать неизменяемые объекты. Использовать синхронизацию записи.**
## 3. Deadlock (взаимная блокировка)

- потоки в вечном ожидании друг друга
- cyclic dependency
- **Решение. Добавить таймауты. Внести логирование и метрики дедлоков, выявлять критические секции**

## 4. LiveLock 

- потоки шевелятся, анлочат объект, но прогресса нет: Активная пустая деятельность
- **Решение: ограничивать количество попыток и ретраев. Экспоненцировать задержку**

## 5. Lock Starvation (голодание по ресурсам)

- потоку не хватает ресурсов для исполнения процесса
- **Решение: fair-локи - ресурс берут потоки ожидающие больше всего**

## 6. Priority inversion 
- высокоприоритетные потоки не могут стартовать свою работу за счет того, что низкоприоритетные держат лок
