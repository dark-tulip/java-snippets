## Резюме по разбору настроек HikariCP и PGbouncer
Разобрались с настройками HikariCP и PGbouncer на одном из наших тестовых проектов. Вот основные выводы:

### 1. Почему количество соединений не всегда 50?

- HikariCP динамически регулирует соединения в зависимости от нагрузки и настроек (minimumIdle, maximumPoolSize).
- PGbouncer работает в `transaction` режиме, что означает, что он выделяет соединение **только на время транзакции, а затем возвращает его в пул**.
- В периоды простоя HikariCP держит меньше соединений, чем **maxPoolSize**.
- В периоды нагрузки возможно кратковременное превышение соединений, если используется `reserve_pool` (резервные соединения, которые используются `pgbouncer` если основной пул (pool_size) заполнен) или если HikariCP создаёт новые соединения при необходимости.

### 2. Как проверить текущие соединения?
Выполни в PostgreSQL:

```sql
SELECT datname, usename, state, count(*) 
FROM pg_stat_activity 
GROUP BY datname, usename, state;
```
Примечание:
- Если есть много `idle in transaction` - соединения зависают
- Если `active` соединений меньше, чем ожидалось, значит, **пул работает гибко** и не держит 50 коннектов постоянно
  
### 3. Как убедиться, что PGbouncer не мешает HikariCP?
Важно, чтобы `pool_mode` внутри `PGbouncer` соответствовал тому, как HikariCP управляет соединениями:

- Если оставить `pool_mode=transaction` в `PgBouncer`, то `HikariCP` должен работать с `autoCommit=false`, чтобы не разрывать транзакции слишком рано

### 4️⃣ Как исправить положение и помочь нашим сервисам, если есть проблемы?

- !Убедись, что `HikariCP.maximumPoolSize * количество реплик ≤ default_pool_size` внутри `PGbouncer`
- настройки pg-bouncer-a можно посмотреть в `pgbouncer-beta.ini` файле в соотв проекте
